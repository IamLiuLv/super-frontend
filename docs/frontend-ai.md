# AI 赋能前端研发从 0 ～ 1

主要会从 [AI 赋能前端研发从 0 ～ 1](/) 小册中抽出比较重要的内容进行分享。 大纲如下 👇

## 大纲

`市场调研和全流程分析`

`开发一个生成业务组件的AI平台`

`如何基于公司私有组件库生成代码`

`集成AI到IDE，打造沉浸式编码工作流`

## 市场调研和全流程分析

### 市场调研

分享一款市场中比较有名的几类产品：

`对话生成页面`：[Dora](https://www.dora.run)、[Vercel V0](https://v0.dev/)

`图片生成页面`：[ScreenShotToCode](https://github.com/abi/screenshot-to-code)、[Draw A UI](https://github.com/SawyerHood/draw-a-ui)

`D2C类型`：[Locofy](https://www.locofy.ai/)、[Builder.io](https://www.builder.io/)

`辅助编码类工具`：[Github Copilot](https://github.com/features/copilot)、[Continue](https://www.continue.dev/)

我们从`两个维度`来分析一下，上面的产品。

**一、从广度**：

现在我们说的前端是大前端，而不是单纯的页面仔，还包括前端工程化、H5、小程序、跨平台、node 全栈等等。以上提到的产品大部分都是在生成 web 页面这一个维度上。

**二、从深度**：

假设我们聚焦在 web 页面研发着一个维度（这个也是大部分前端的一个日常工作），以上产品还存在一个**比较大的问题**：由于内置了一套模版技术栈，因此无法基于公司私有组件生成符合规范的代码。

综合上面两个角度分析，AI 在前端研发领域的应用还有**很大的空间**，不同的公司由于技术栈、研发流程等的不同，因此每个人都是这个领域的探索者。

必须要深入自己的业务场景，才能找到适合的 AI 赋能方案。

### AI 赋能前端全流分析

我们假定现阶段的 AI 已经达到了 AGI 的程度，也就是能够代替人类做任何事情。

::: tip 思考一下
你在完成某一件任务之前，是不是得有一个思考和工作流程拆分的步骤，而不是直接上手就做。
:::

我们会把工作拆分成`一个个的环节`、`步骤`，然后一个个步骤来做，一个个环节来完成。

`AI 同样如此。`

我们把上面拆分步骤、环节的过程图形化一下，得到一个形状为`金字塔`的模型。

![](https://lvjishupai.oss-cn-beijing.aliyuncs.com/20240324201241.png)

如上图，针对一个业务工作流，我们会按照如下流程进行 AI 的赋能：

1. 尝试直接用 AI 处理这个大的业务，`不做任何拆分`，发现 AI 做的一团乱。

2. 尝试将大的业务`拆分为不同的环节`，然后逐个环节进行 AI 的融入，发现 AI 做的还不是很满意。

3. 再尝试将不同的环节`拆分为不同的步骤`，然后逐个步骤进行 AI 的融入，发现这个时候 AI 生成的内容才符合标准。

以上，针对不同的业务，进行不同程度的工作流拆分，逐个`环节`、`步骤`来尝试融入 AI，同时来检验 AI 生成内容的效果。

我把上面的步骤统称为：`AI赋能金字塔模型`

运用`AI赋能金字塔模型`的理念，我们拆分一下前端的工作流。

![](https://lvjishupai.oss-cn-beijing.aliyuncs.com/20240718095554.png)

如上，针对`前端页面研发`的这个场景，我们最终拆分为了：

**2 个环节**

- 业务组件开发

- 对接联调（拼装业务组件为页面，页面的数据对接）

**4 个步骤**

- 从 `0 ～ 1` 开发业务组件

- 从 `1 ～ 100` 进行业务组件的迭代

- 从 `0 ～ 1` 对接

- 从 `1 ～ 100` 迭代对接

其中，重点是`从 0 ～ 1 开发业务组件`，因为它占据了整个研发流程中`80%`左右的时间。

## 开发一个生成业务组件的 AI 平台

### 整洁的业务组件架构

`核心原则`：服务端状态和前端状态分离

![](https://lvjishupai.oss-cn-beijing.aliyuncs.com/20240429062204.png)

- 所有业务组件均可独立运行

- 业务组件中不能直接请求 api 数据，需要触发接口请求的地方通过 props 回调给到外部对接层。

`这样做的好处：`

- 功能职责单一：业务组件可独立运行，不依赖于外部数据，api 的对接层也不依赖于业务组件。

- 整体的数据流向十分清晰：对接层请求数据给到业务组件层，业务组件通过 props 回调触发对接层的数据变更。

- 高内聚、低耦合：业务组件只关心自己的业务逻辑，对接层只关心数据的请求和处理。

`代码结构`

```ts
StorybookExample // 业务组件名称
├─ index.ts // 仅仅将组件内容暴露给外部
├─ interface.ts // 定义组件内部用到的所有类型，包括 interface、type、enum等
├─ StorybookExample.stories.tsx // 组件的storybook文档，包含组件的使用示例
├─ StorybookExample.tsx // 组件的主体逻辑，如果组件太大可以拆分为其它的文件
├─ styles.ts // 组件所有的样式资源存放在此，使用styled-components来编写
├─ helpers.ts // 如果存在一些工具函数，那放在此处
├─ StorybookExample.test.tsx // 存放业务组件的单元测试
```

### 使用 AI 生成业务组件

### 开发生成业务组件的 AI 平台

## 如何基于公司私有组件库生成代码

## 集成 AI 到 IDE，打造沉浸式编码工作流
